!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!  This module contains code for constructing and manipulating piecewise Legendre
!  expansions given on rectangles.  Such an expansion is a sum of the form
!  
!     n-1   n-1-i                  (   2       x1+x2 )            (   2         y1+y2 )  
!    \sum   \sum   a    \tilde{P}  ( ----- x + ----- ) \tilde{P}  ( ----  y  +  ----- ) 
!     i=0    j=0    ij           i ( x2-x1     x1-x2 )          j ( y2-y1       y1-y2 )  
!
!                                    2 
!                       ------------------------- ,
!                        sqrt(x2-x1) sqrt(y2-y1)
! 
!  where \tilde{P}_i denotes the L^2 normalized Legendre polynomial given on the
!  interval [-1,1] and (x1,x2) x (y1,
!
!  Each bivariate Legendre expansion can be represented in two different ways, via the 
!  vector of expansion coefficients or via the scaled values of the expansion at the
!  nodes of a generalized Gaussian quadrature rule (see bilege.f90 for details).
!  Piecewise expansions over the entire restricted quadtree are represented by
!  amalgamating these vectors.  The leaves are ordered according to a depth-first
!  traversal of the tree with child boxes ordered as follows: upper left, followed
!  by upper right, then lower right and, finally, lower left.
!  
!  The order of the expansions used and various other parameters are hard-coded
!  in the routine discinit.  Precomputed near-interaction, generated by the
!  precomp.f90 program and stored in nearmats.f90, are used by this code and
!  need to be recalculated if the order of expansions changes.
!
!  For the most part, these routines are not multithreaded.  There are a handful
!  of utility routines which have multithreaded versions which end with the _mt
!  postfix.
!
!  The following subroutines are publicly callable:
!
!    discrect_init - initialize this discretization code; this routine MUST be called
!      before any of the other subroutines here
!
!    discrect_info - return some basic information about the quadrature scheme used
!      by this discretization code
!
!    discrect_adap - adaptively refine a restricted quadtree until a user-specified
!      functions is accurately represented as a piecewise bivariate Legendre expansion
!      subordinate to the leaf nodes of the quadtree
!
!    discrect_uniform - repeatedly subdivide each leaf box until all leaf
!      boxes have side length smaller than a specified size
!
!    discrect_reorder_leaves - reorder the list of leaves in the tree so that
!      every box has the property that the discretization nodes of all
!      leaves descended from it are sequential
!
!    discrect_quad - return the piecewise tensor product Legendre quadrature
!      used to discretize functions (also referred to as the "discretization 
!      quadrature"
!
!    discrect_isnear - determine whether a specified target box is "near"
!      a specified source box or not 
!
!    discrect_quadleaf - return the quadrature used to discretize the expansion
!      on one specified leaf node
!  
!    discrect_coefs - given the vector of *scaled* values of a function at the 
!      nodes of the discretization quadrature rule, compute the coefficients in each
!      of the biviarate Legendre expansions used to represent the function
!
!    discrect_eval - given the vector of expansion coefficients, evaluate a
!      piecewise bivariate expansion on the quadtree at a specified point
!
!    discrect_evalop - evaluate an arbitrary submatrix of the matrix discretizing
!      one of the operators (1), (2) or (3)
!
!    discrect_evalop_sorted - evaluate an arbitrary submatrix of the matrix 
!      discretizing one of the operators (1), (2) or (3) --- with the lists of
!      rows and columns sorted
!
!    discrect_evalopt_sorted - evaluate the transpose of an arbitrary submatrix of 
!      the matrix discretizing one of the operators (1), (2) or (3)
!
!    discrect_evalop_matrix - this is a convenience routine which evaluates the entire 
!      matrix discretizing one of the operators (1), (2) or (3)
!
!      THERE IS A MULTITHEADED VERSION OF THIS CODE WITH THE _mt POSTFIX
!
!    discrect_applyop - this is a convenience routine for applying one the of operators
!      (1), (2) or (3) to a user-specified vector
!
!      THERE IS A MULTITHEADED VERSION OF THIS CODE WITH THE _mt POSTFIX
!
!    disrect_evalop_outgoing - construct the matrix taking the scaled values of an
!      input function on a specified set of discretization nodes to the scaled values
!      of its image under (1), (2) or (3) at the nodes of an user-specified quadrature
!      rule PROVIDED the target quadrature nodes are sufficiently distant from the
!      source quadrature rules (sufficiently distance is defined by "dnear" parameter)
!
!    disrect_evalop_incoming - construct the transpose of the matrix taking the scaled 
!      values of an input function at the nodes of an user-specified quadrature in the 
!      far-field to the scaled values of its image under one (1), (2) or (3) at a specified
!      set of interpolation nodes
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!  Reasonable settings for the quadrature parameters
!  -------------------------------------------------
!
!  The order of discretization quadrature and the desired accuracy for the discretization
!  control the notion of "near" interaction.  Below are some reasonable settings of the
!  parameters in disc_init for desired levels of precision.  The program farq can be
!  used to test these settings.
!


!  WARNING: WHEN THE ORDER OF THE QUADRATURE RULE IS CHANGED, THE PROGRAM PRECOMP MUST
!  BE RERUN TO GENERATE THE DATA IN nearmats.f90!!  NOTE TAHT ONE MUST MANUALLY SET THE
!  ORDER OF THE DISCRETIZATION QUADRATURE IN precomp.f90.
!
!
!   5-digit precision:         norder = 10, dnear = 0.50, nlege = N/A
!   7-digit precision:         norder = 10, dnear = 1.00, nlege = 9 
!
!   6-digit precision:         norder = 12  dnear = 0.50, nlege = N/A
!   9-digit precision:         norder = 12, dnear = 1.00, nlege = 12
!  12-digit precision:         norder = 12, dnear = 2.50, nlege = 15
!
!   9-digit precision:         norder = 16, dnear = 0.50, nlege = N/A
!  12-digit precision:         norder = 16, dnear = 1.00, nlege = 16
!  14-digit precision:         norder = 16, dnear = 1.50, nlege = 18
!
!  10-digit precision:         norder = 20, dnear = 0.50, nlege = N/A
!  12-digit precision:         norder = 20, dnear = 0.75, nlege = 16
!  14-digit precision:         norder = 20, dnear = 1.00, nlege = 18
!
!  12-digit precision:         norder = 24, dnear = 0.50, nlege = N/A
!  14-digit precision:         norder = 24, dnear = 0.75, nlege = 19
!
!  14-digit precision:         norder = 30, dnear = 0.50, nlege = N/A
!  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

module discrect

use utils
use legendre
use sqquads
use bilege
use resquad
use nearmats


! these variables are used by the 
integer, private                             ::  norder, nquad0, nquadnear
double precision, private                    ::  dnear
double precision, allocatable, private       ::  xs0(:),ys0(:),whts0(:)
double precision, allocatable, private       ::  umatr0(:,:), amatrnear(:,:)
double precision, allocatable, private       ::  xsnear(:),ysnear(:),whtsnear(:)
integer, private                             ::  nconfigs
double precision, allocatable, private       ::  configs(:,:)

interface

subroutine discrect_adapfun(n,xs,ys,vals)
double precision           :: xs(n),ys(n)
double complex             :: vals(n)

end subroutine
end interface

contains




subroutine discrect_init()
implicit double precision (a-h,o-z)
!
!  Initialize this discretization code.  This subroutine must be called before
!  any other subroutine in this module.
!
!  Input parameters:
!    N/A
!
!  Output parameters:
!    N.A
!
double precision, allocatable  :: xslege(:),whtslege(:)

double precision, allocatable  :: amatr(:,:),bmatr(:,:)
integer, allocatable           :: idxs(:)


! this should get about 10-digit accuracy or thereabouts
norder    = 20
dnear     = 0.5d0
nlege     = 18

call bilege_quad(norder,nquad0,xs0,ys0,whts0)
call bilege_coefsmatrix(norder,umatr0)
call legendre_quad(nlege,xslege,whtslege)
nquadnear = nlege*nlege

if (allocated(xsnear))   deallocate(xsnear)
if (allocated(ysnear))   deallocate(ysnear)
if (allocated(whtsnear)) deallocate(whtsnear)

allocate(xsnear(nquadnear),ysnear(nquadnear),whtsnear(nquadnear))

idx = 0
do i=1,nlege
do j=1,nlege
idx           = idx+1
xsnear(idx)   = xslege(i)
ysnear(idx)   = xslege(j)
whtsnear(idx) = whtslege(i)*whtslege(j)
end do
end do

! build the near interpolation matrix
call bilege_intmatrix(norder,nquadnear,xsnear,ysnear,whtsnear,amatrnear)

! Fetch the possible configuations of neighbors
call resquad_configs(nconfigs,configs)

call prini("in discrect_init, norder    = ",norder)
call prini("in discrect_init, nquad0    = ",nquad0)
call prin2("in discrect_init, dnear     = ",dnear)
call prini("in discrect_init, nquadnear = ",nquadnear)


end subroutine


subroutine discrect_info(norder0,nquad00,dnear00)
implicit double precision (a-h,o-z)
!
!  Return basic information about the quadrature scheme used by this
!  discretization code.
!
!  Input parameters:
!    N/A
!
!  Output parameters:
!    norder0 - the order of the bivariate Legendre expansions on
!      each leaf node
!    nquad00 - the number of nodes in the quadrature used to
!      represent those expansions
!    dnear00 - the parameter used to determine the notion of near
!      interaction for the purposes of discretization
!

norder0  = norder
nquad00  = nquad0
dnear00  = dnear

end subroutine


subroutine discrect_adap(eps,tree,fun)
implicit double precision (a-h,o-z)
type(resquadtree)                   :: tree
procedure(discrect_adapfun)         :: fun
!
!  Adaptively refine the restricted quadtree until it represents an user-supplied
!  external function to a specified accuracy.
!
!  Input parameters:
!    eps - the desired accuracy for the adaptive discretization
!    tree - the restricted quadtree structure
!    fun - an external subroutine which supplies the user-specified function
!
!  Output parameters:
!    tree - the data structure describing the newly refined restriceted
!      quadtree
!

integer, allocatable          :: istack(:)
double precision, allocatable :: xs(:),ys(:),whts(:)
double complex, allocatable   :: vals(:),coefs(:)

maxstack = 1000000

allocate(istack(maxstack))
allocate(xs(nquad0),ys(nquad0),whts(nquad0))
allocate(vals(nquad0),coefs(nquad0))

nleaves            = tree%nleaves
nstack             = nleaves
istack(1:nleaves)  = tree%ileaves(1:nleaves)

do while (nstack .gt. 0)
ibox   = istack(nstack)
nstack = nstack-1
call resquad_boxinfo(tree,ibox,idx,iparent,ilevel,x1,y1,x2,y2,iul,iur,ilr,ill)


if (idx .eq. 0) then

if (nstack .gt. maxstack) then
call prina("in discrect_adap, stack overflow")
stop
endif

nstack = nstack+1
istack(nstack) = iul
nstack = nstack+1
istack(nstack) = iur
nstack = nstack+1
istack(nstack) = ilr
nstack = nstack+1
istack(nstack) = ill

cycle
endif

xs   = xs0*(x2-x1)/2 + (x2+x1)/2
ys   = ys0*(y2-y1)/2 + (y2+y1)/2
whts = whts0*(y2-y1)/2 * (x2-x1)/2

call fun(nquad0,xs,ys,vals)
vals = vals * sqrt(whts)

call bilege_coefs(norder,vals,coefs)
coefs = coefs / maxval(abs((coefs)))

idx1 = nquad0-norder*3
idx2 = nquad0
dd   = maxval(abs(coefs(idx1:idx2)))

if (dd .gt. eps) then


call resquad_split(tree,ibox,iul,iur,ilr,ill)

nstack = nstack+1
istack(nstack) = iul
nstack = nstack+1
istack(nstack) = iur
nstack = nstack+1
istack(nstack) = ilr
nstack = nstack+1
istack(nstack) = ill

endif

end do

end subroutine


subroutine discrect_uniform(tree,dsize)
implicit double precision (a-h,o-z)
type(resquadtree)       :: tree
!
!  Repeatedly subdivide all leaf boxes in the tree until the side lengths
!  of each leaf box is less than or equal to dsize.
!
!  Input parameters:
!    tree - the data structure describing the restricted quadtree
!    dsize - the maximum permissible size for a leaf box
!
!  Output parameters:
!    tree  - the restricted quadtree is updated
!

integer, allocatable  :: istack(:)

maxboxes = tree%maxboxes
allocate(istack(maxboxes))

nstack           = tree%nleaves
istack(1:nstack) = tree%ileaves

do while( nstack > 0 ) 

ibox   = istack(nstack)
nstack = nstack-1

ileaf  = tree%boxes(ibox)%ileaf
x1     = tree%boxes(ibox)%x1
y1     = tree%boxes(ibox)%y1
x2     = tree%boxes(ibox)%x2
y2     = tree%boxes(ibox)%y2
iul    = tree%boxes(ibox)%ichildul
iur    = tree%boxes(ibox)%ichildur
ilr    = tree%boxes(ibox)%ichildlr
ill    = tree%boxes(ibox)%ichildll

dlen   = x2-x1

if (ileaf .eq. 0) then
nstack         = nstack+1
istack(nstack) = iul
nstack         = nstack+1
istack(nstack) = iur
nstack         = nstack+1
istack(nstack) = ilr
nstack         = nstack+1
istack(nstack) = ill
cycle
endif

if (dlen .gt. dsize) then
call resquad_split(tree,ibox,iul,iur,ilr,ill)

nstack         = nstack+1
istack(nstack) = iul
nstack         = nstack+1
istack(nstack) = iur
nstack         = nstack+1
istack(nstack) = ilr
nstack         = nstack+1
istack(nstack) = ill
endif

end do

end subroutine




subroutine discrect_quad(tree,nquad,xs,ys,whts)
implicit double precision (a-h,o-z)
type(resquadtree)                                    :: tree
double precision, allocatable, intent(out)           :: xs(:),ys(:),whts(:)
!
!  Return the quadrature used to represent the piecewise bivariate Legendre
!  expansions on the entire domain R.
!
!  Input parameters:
!    tree - the data structure describing the restricted quadtree
!
!  Output parameters:
!    nquad - the number of nodes in the quadrature rules
!    (xs,ys) - the coordinates of the quadrature nodes
!    whts - the array of quadrature weights
!

nleaves = tree%nleaves
nquad   = nleaves*nquad0

allocate(xs(nquad),ys(nquad),whts(nquad))

i1 = 1
i2 = nquad0

do idx=1,nleaves
call resquad_leafinfo(tree,idx,ibox,ilevel,x1,y1,x2,y2)

xs(i1:i2)   = xs0*(x2-x1)/2 + (x2+x1)/2
ys(i1:i2)   = ys0*(y2-y1)/2 + (y2+y1)/2
whts(i1:i2) = whts0*(x2-x1)/2 * (y2-y1)/2

i1 = i1+nquad0
i2 = i2+nquad0
end do

end subroutine


subroutine discrect_quadleaf(tree,idx,nquad,xs,ys,whts)
implicit double precision (a-h,o-z)
type(resquadtree)                                    :: tree
double precision, allocatable, intent(out)           :: xs(:),ys(:),whts(:)
!
!  Return the quadrature used to represent expansions on a specified
!  leaf node.
!
!  Input parameters:
!    tree - the data structure describing the restricted quadtree
!
!  Output parameters:
!    nquad - the number of nodes in the quadrature rules
!    (xs,ys) - the coordinates of the quadrature nodes
!    whts - the array of quadrature weights
!

allocate(xs(nquad0),ys(nquad0),whts(nquad0))
call resquad_leafinfo(tree,idx,ibox,ilevel,x1,y1,x2,y2)
xs    = xs0*(x2-x1)/2 + (x2+x1)/2
ys    = ys0*(y2-y1)/2 + (y2+y1)/2
whts  = whts0*(x2-x1)/2 * (y2-y1)/2

end subroutine


subroutine discrect_coefs(tree,vals,coefs)
implicit double precision (a-h,o-z)
type(resquadtree)      :: tree
double complex         :: vals(:), coefs(:)
!
!  Given the vector of scaled values of a piecewise bivariate expansion at
!  the nodes of the discretization quadrature, compute the piecewise
!  coefficient expansions.
!
!  Input parameters:
!    tree - the data structure describing the restricted quadtree
!    vals - the vector of scaled values
!
!  Output parameters:
!    coefs - the vector of expansion coefficients
!

call resquad_info(tree,nlevels,nboxes,nleaves)

do idx=1,nleaves
i1   = 1 + (idx-1)*nquad0
i2   = idx*nquad0

call resquad_leafinfo(tree,idx,ibox,ilevel,x1,y1,x2,y2)
call bilege_coefs(norder,vals(i1:i2),coefs(i1:i2))
end do

end subroutine


subroutine discrect_eval(tree,coefs,x,y,val)
implicit double precision (a-h,o-z)
type(resquadtree)      :: tree
double complex         :: coefs(:), val
!
!  Given the coefficients in a piecewise expansion, compute its value at
!  a specified point.
!
!  Input parameters:
!    tree - the data structure describing the restricted quadtree
!    coefs - the vector of expansion coefficients
!    (x,y) - the point at which to evaluate the expansion
!
!  Output parameters:
!    val - the value of the expansion at the point (x,y)
!

double complex, allocatable :: vals0(:),coefs0(:)
call resquad_search(tree,x,y,idx)
call resquad_leafinfo(tree,idx,ibox,ilevel,x1,y1,x2,y2)

i1 = 1+nquad0*(idx-1)
i2 = nquad0*idx

xx   = (2*x - (x2+x1) ) /(x2-x1)
yy   = (2*y - (y2+y1) ) /(y2-y1)
call bilege_eval(norder,coefs(i1:i2),xx,yy,val)
val = val * 2/(x2-x1)

end subroutine


subroutine discrect_isnear(tree,itarbox,isrcbox,ifnear)
implicit double precision (a-h,o-z)
type(resquadtree)              :: tree
!
!  Determine whether or not a specified target box (which need not be a leaf) is near to
!  a specified leaf box in the sense that a special quadrature is used to evaluate
!  the interaction.
!
!  Input parameter:
!    tree - a data structure describing the restricted quadtree
!    itarbox - the index of the target box
!    isrcbox - the index of the source leaf box
!
!  Ouptut parameter:
!    ifnear - 0 if the target box is not near and 1 if it is 
!
!

x1      = tree%boxes(isrcbox)%x1
y1      = tree%boxes(isrcbox)%y1
x2      = tree%boxes(isrcbox)%x2
y2      = tree%boxes(isrcbox)%y2
dlen    = x2-x1
x1      = x1 - dlen*dnear
x2      = x2 + dlen*dnear
y1      = y1 - dlen*dnear
y2      = y2 + dlen*dnear

z1      = tree%boxes(itarbox)%x1
w1      = tree%boxes(itarbox)%y1
z2      = tree%boxes(itarbox)%x2
w2      = tree%boxes(itarbox)%y2

ifnear  = 1
if (z2 .le. x1) ifnear = 0
if (z1 .ge. x2) ifnear = 0
if (w1 .ge. y2) ifnear = 0
if (w2 .le. y1) ifnear = 0

end subroutine



subroutine discrect_evalop_matrix(tree,ikernel,amatr)
implicit double precision (a-h,o-z)
type(resquadtree)                                :: tree
double precision, allocatable, intent(out)       :: amatr(:,:)

!
!  Return the entire matrix discretizing one of the operators (1), (2) or (3).
!
!  Input parameters:
!    tree - the data structure describing the restricted quadtree
!    ikernel - an integer parameter indicating which operator is to be
!      evaluated:
!
!        ikernel = 1   means evaluate a submatrix of the discretization of (1)
!        ikernel = 2   means evaluate a submatrix of the discretization of (2)
!        ikernel = 3   means evaluate a submatrix of the discretization of (3)
!
!  Output parameters:
!    amatr - the desired discretization matrix
!
!

integer, allocatable :: idxs(:)

call resquad_info(tree,nlevels,nboxes,nleaves)

nquad = nquad0*nleaves
allocate(amatr(nquad,nquad))

do itar=1,nleaves
do isrc=1,nleaves

i1 = 1 + (itar-1)*nquad0
i2 = itar*nquad0

j1 = 1 + (isrc-1)*nquad0
j2 = isrc*nquad0
call discrect_evalop_block(tree,ikernel,itar,isrc,amatr(i1:i2,j1:j2))
end do
end do

end subroutine

subroutine discrect_evalop_matrix_mt(tree,ikernel,amatr)
implicit double precision (a-h,o-z)
type(resquadtree)                                :: tree
double precision, allocatable, intent(out)       :: amatr(:,:)
!
!  Return the entire matrix discretizing one of the operators (1), (2) or (3).
!  This routine is multithreaded.
!
!  Input parameters:
!    tree - the data structure describing the restricted quadtree
!    ikernel - an integer parameter indicating which operator is to be
!      evaluated:
!
!        ikernel = 1   means evaluate a submatrix of the discretization of (1)
!        ikernel = 2   means evaluate a submatrix of the discretization of (2)
!        ikernel = 3   means evaluate a submatrix of the discretization of (3)
!
!  Output parameters:
!    amatr - the desired discretization matrix
!

call resquad_info(tree,nlevels,nboxes,nleaves)
nquad = nquad0*nleaves
allocate(amatr(nquad,nquad))


!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(idx,isrc,itar,i1,i2,j1,j2)
!$OMP DO
do idx=0,nleaves*nleaves-1

isrc = mod(idx,nleaves)
itar = (idx-isrc)/nleaves
isrc = isrc+1
itar = itar+1

i1 = 1 + (itar-1)*nquad0
i2 = itar*nquad0

j1 = 1 + (isrc-1)*nquad0
j2 = isrc*nquad0

call discrect_evalop_block(tree,ikernel,itar,isrc,amatr(i1:i2,j1:j2))


end do
!$OMP END DO
!$OMP END PARALLEL

end subroutine


subroutine discrect_applyop(tree,ikernel,xx,yy)
implicit double precision (a-h,o-z)
type(resquadtree)                                :: tree
double complex                                   :: xx(:),yy(:)
!
!  Apply the matrix discretizing one of the operators (1), (2) or (3) to a 
!  user-supplied vector.
!
!  Input parameters:
!    tree - the data structure describing the restricted quadtree
!    ikernel - an integer parameter indicating which operator is to be
!      evaluated:
!
!        ikernel = 1   means evaluate a submatrix of the discretization of (1)
!        ikernel = 2   means evaluate a submatrix of the discretization of (2)
!        ikernel = 3   means evaluate a submatrix of the discretization of (3)
!
!    xx - the vector to which the discretization matrix should be applied
!
!  Output parameters:
!    yy - the resulting vector
!
!
double precision, allocatable :: amatr(:,:)
double complex, allocatable   :: zz(:)

call resquad_info(tree,nlevels,nboxes,nleaves)
allocate(amatr(nquad0,nquad0), zz(nquad0) )
 
yy = 0

do itar=1,nleaves
do isrc=1,nleaves

i1 = 1 + (itar-1)*nquad0
i2 = itar*nquad0

j1 = 1 + (isrc-1)*nquad0
j2 = isrc*nquad0

call discrect_evalop_block(tree,ikernel,itar,isrc,amatr)
zz        = matmul(amatr,xx(j1:j2))
yy(i1:i2) = yy(i1:i2) + zz
end do
end do

end subroutine

subroutine discrect_applyop_mt(tree,ikernel,xx,yy)
implicit double precision (a-h,o-z)
type(resquadtree)                                :: tree
double complex                                   :: xx(:),yy(:)
!
!  Apply the matrix discretizing one of the operators (1), (2) or (3) to a 
!  user-supplied vector.
!
!  Input parameters:
!    tree - the data structure describing the restricted quadtree
!    ikernel - an integer parameter indicating which operator is to be
!      evaluated:
!
!        ikernel = 1   means evaluate a submatrix of the discretization of (1)
!        ikernel = 2   means evaluate a submatrix of the discretization of (2)
!        ikernel = 3   means evaluate a submatrix of the discretization of (3)
!
!    xx - the vector to which the discretization matrix should be applied
!
!  Output parameters:
!    yy - the resulting vector
!
!
double precision, allocatable :: amatr(:,:)
integer, allocatable          :: itars(:),isrcs(:)
double complex, allocatable   :: zz(:)

call resquad_info(tree,nlevels,nboxes,nleaves)

 
yy = 0

!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(amatr,idx,isrc,itar,i1,i2,j1,j2,i,zz)
allocate(amatr(nquad0,nquad0), zz(nquad0) )
!$OMP DO REDUCTION(+:yy)
do idx=0,nleaves*nleaves-1

isrc = mod(idx,nleaves)
itar = (idx-isrc)/nleaves
isrc = isrc+1
itar = itar+1

i1 = 1 + (itar-1)*nquad0
i2 = itar*nquad0

j1 = 1 + (isrc-1)*nquad0
j2 = isrc*nquad0

call discrect_evalop_block(tree,ikernel,itar,isrc,amatr)
zz         =  matmul(amatr,xx(j1:j2))
yy(i1:i2) = yy(i1:i2) + zz

end do
!$OMP END DO
!$OMP END PARALLEL

end subroutine



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!  Operator evaluation routines
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine discrect_evalop(tree,ikernel,ntars,itars,nsrcs,isrcs,amatr)
implicit double precision (a-h,o-z)
type(resquadtree)      :: tree
integer                :: itars(ntars), isrcs(nsrcs)
double precision       :: amatr(:,:)
!
!  Evaluate an arbitrary submatrix of the matrix discretizing one of the
!  operators (1), (2) or (3).
!
!  Input parameters:
!    tree - the data structure describing the restricted quadtree
!    ikernel - an integer parameter indicating which operator is to be
!      evaluated:
!
!        ikernel = 1   means evaluate a submatrix of the discretization of (1)
!        ikernel = 2   means evaluate a submatrix of the discretization of (2)
!        ikernel = 3   means evaluate a submatrix of the discretization of (3)
!
!   ntars - the number of targets
!   itars - the list of targets
!   nsrcs - the number of sources
!   isrcs - the list of sources
!
!  Output parameters:
!    amatr - the (ntars,nsrcs) matrix

data pi / 3.14159265358979323846264338327950288d0 /
integer, allocatable          :: itars00(:), itars0(:), itarsidxs(:)
integer, allocatable          :: isrcs00(:), isrcs0(:), isrcsidxs(:)
double precision, allocatable :: cmatr(:,:)


!allocate(cmatr(nquad0,nquad0))

!
!  Sort the lists of target and source points; keep track of the
!  ordering.
!

allocate(itars00(ntars), itars0(ntars), itarsidxs(ntars))
allocate(isrcs00(nsrcs), isrcs0(nsrcs), isrcsidxs(nsrcs))

itars0 = itars
isrcs0 = isrcs

call  quicksorti2(ntars,itars0,itarsidxs)
call  quicksorti2(nsrcs,isrcs0,isrcsidxs)

i1 = 0
i2 = 0

!
!  Loop over all target boxes
!

do while(i2 .lt. ntars) 

i1      = i2+1
itarbox = (itars0(i1)-1)/nquad0+1
i3      = 1+(itarbox-1)*nquad0
i4      = (itarbox)*nquad0


do while(i2 .lt. ntars) 
if( itars0(i2+1) .le. i4) then
i2=i2+1
else
exit
endif
end do

!
!  Loop over all source boxes
!

j1     = 0
j2     = 0

do while(j2 .lt. nsrcs) 

j1      = j2+1
isrcbox = (isrcs0(j1)-1)/nquad0+1
j3      = 1+(isrcbox-1)*nquad0
j4      = (isrcbox)*nquad0

do while(j2 .lt. nsrcs) 
if( isrcs0(j2+1) .le. j4) then
j2=j2+1
else
exit
endif
end do

!
!  Call a utility routine to evaluate the appropriate submatrix for this target
!  and this source
!

nn = i2-i1+1
mm = j2-j1+1
itars00(1:nn) = itars0(i1:i2)-i3+1
isrcs00(1:mm) = isrcs0(j1:j2)-j3+1

allocate(cmatr(nn,mm))
call discrect_evalop0(tree,ikernel,itarbox,isrcbox,nn,itars00,mm,isrcs00,cmatr)
amatr(itarsidxs(i1:i2),isrcsidxs(j1:j2)) = cmatr
deallocate(cmatr)

end do
end do

end subroutine

subroutine discrect_evalopt(tree,ikernel,ntars,itars,nsrcs,isrcs,amatr)
implicit double precision (a-h,o-z)
type(resquadtree)      :: tree
integer                :: itars(ntars), isrcs(nsrcs)
double precision       :: amatr(:,:)
!
!  Evaluate the transpose of an  arbitrary submatrix of the matrix discretizing 
!  one of the operators (1), (2) or (3).
!
!  Input parameters:
!    tree - the data structure describing the restricted quadtree
!    ikernel - an integer parameter indicating which operator is to be
!      evaluated:
!
!        ikernel = 1   means evaluate a submatrix of the discretization of (1)
!        ikernel = 2   means evaluate a submatrix of the discretization of (2)
!        ikernel = 3   means evaluate a submatrix of the discretization of (3)
!
!   ntars - the number of targets
!   itars - the list of targets
!   nsrcs - the number of sources
!   isrcs - the list of sources
!
!  Output parameters:
!    amatr - the (ntars,nsrcs) matrix

data pi / 3.14159265358979323846264338327950288d0 /
integer, allocatable          :: itars00(:), itars0(:), itarsidxs(:)
integer, allocatable          :: isrcs00(:), isrcs0(:), isrcsidxs(:)
double precision, allocatable :: cmatr(:,:)


!
!  Sort the lists of target and source points; keep track of the
!  ordering.
!

allocate(itars00(ntars), itars0(ntars), itarsidxs(ntars))
allocate(isrcs00(nsrcs), isrcs0(nsrcs), isrcsidxs(nsrcs))

itars0 = itars
isrcs0 = isrcs

call  quicksorti2(ntars,itars0,itarsidxs)
call  quicksorti2(nsrcs,isrcs0,isrcsidxs)

i1 = 0
i2 = 0

!
!  Loop over all target boxes
!

do while(i2 .lt. ntars) 

i1      = i2+1
itarbox = (itars0(i1)-1)/nquad0+1
i3      = 1+(itarbox-1)*nquad0
i4      = (itarbox)*nquad0


do while(i2 .lt. ntars) 
if( itars0(i2+1) .le. i4) then
i2=i2+1
else
exit
endif
end do

!
!  Loop over all source boxes
!

j1     = 0
j2     = 0

do while(j2 .lt. nsrcs) 

j1      = j2+1
isrcbox = (isrcs0(j1)-1)/nquad0+1
j3      = 1+(isrcbox-1)*nquad0
j4      = (isrcbox)*nquad0

do while(j2 .lt. nsrcs) 
if( isrcs0(j2+1) .le. j4) then
j2=j2+1
else
exit
endif
end do

!
!  Call a utility routine to evaluate the appropriate submatrix for this target
!  and this source
!

nn = i2-i1+1
mm = j2-j1+1
itars00(1:nn) = itars0(i1:i2)-i3+1
isrcs00(1:mm) = isrcs0(j1:j2)-j3+1

allocate(cmatr(mm,nn))
call discrect_evalopt0(tree,ikernel,itarbox,isrcbox,nn,itars00,mm,isrcs00,cmatr)
amatr(isrcsidxs(j1:j2),itarsidxs(i1:i2)) = cmatr
deallocate(cmatr)

end do
end do

end subroutine

subroutine discrect_evalop_sorted(tree,ikernel,ntars,itars,nsrcs,isrcs,a)
implicit double precision (a-h,o-z)
type(resquadtree)      :: tree
integer                :: itars(ntars), isrcs(nsrcs)
double precision       :: a(:,:)
!
!  Evaluate an arbitrary submatrix of the matrix discretizing one of the
!  operators (1), (2) or (3).  
!
!  THIS VERSION OF THE CODE ASSUMES THE LISTS OF SOURCES AND TARGETS ARE
!  SORTED.
!
!  Input parameters:
!    tree - the data structure describing the restricted quadtree
!    ikernel - an integer parameter indicating which operator is to be
!      evaluated:
!
!        ikernel = 1   means evaluate a submatrix of the discretization of (1)
!        ikernel = 2   means evaluate a submatrix of the discretization of (2)
!        ikernel = 3   means evaluate a submatrix of the discretization of (3)
!
!   ntars - the number of targets
!   itars - the list of targets
!   nsrcs - the number of sources
!   isrcs - the list of sources
!
!  Output parameters:
!    a - the (lda,nsrcs) matrix

data pi / 3.14159265358979323846264338327950288d0 /
integer, allocatable          :: itars00(:), itars0(:), itarsidxs(:)
integer, allocatable          :: isrcs00(:), isrcs0(:), isrcsidxs(:)


allocate(itars00(ntars))
allocate(isrcs00(nsrcs))

i1 = 0
i2 = 0

!
!  Loop over all target boxes
!

do while(i2 .lt. ntars) 

i1      = i2+1
itarbox = (itars(i1)-1)/nquad0+1
i3      = 1+(itarbox-1)*nquad0
i4      = (itarbox)*nquad0


do while(i2 .lt. ntars) 
if( itars(i2+1) .le. i4) then
i2=i2+1
else
exit
endif
end do

!
!  Loop over all source boxes
!

j1     = 0
j2     = 0

do while(j2 .lt. nsrcs) 

j1      = j2+1
isrcbox = (isrcs(j1)-1)/nquad0+1
j3      = 1+(isrcbox-1)*nquad0
j4      = (isrcbox)*nquad0

do while(j2 .lt. nsrcs) 
if( isrcs(j2+1) .le. j4) then
j2=j2+1
else
exit
endif
end do

!
!  Call a utility routine to evaluate the appropriate submatrix for this target
!  and this source
!

nn            = i2-i1+1
mm            = j2-j1+1
itars00(1:nn) = itars(i1:i2)-i3+1
isrcs00(1:mm) = isrcs(j1:j2)-j3+1
call discrect_evalop0(tree,ikernel,itarbox,isrcbox,nn,itars00,mm,isrcs00,a(i1:i2,j1:j2))
end do
end do

end subroutine


subroutine discrect_evalopt_sorted(tree,ikernel,ntars,itars,nsrcs,isrcs,a)
implicit double precision (a-h,o-z)
type(resquadtree)      :: tree
integer                :: itars(ntars), isrcs(nsrcs)
double precision       :: a(:,:)
!
!  Evaluate the transpose of an arbitrary submatrix of the matrix discretizing one 
!  of the operators (1), (2) or (3).  
!
!  THIS VERSION OF THE CODE ASSUMES THE LISTS OF SOURCES AND TARGETS ARE
!  SORTED.
!
!  Input parameters:
!    tree - the data structure describing the restricted quadtree
!    ikernel - an integer parameter indicating which operator is to be
!      evaluated:
!
!        ikernel = 1   means evaluate a submatrix of the discretization of (1)
!        ikernel = 2   means evaluate a submatrix of the discretization of (2)
!        ikernel = 3   means evaluate a submatrix of the discretization of (3)
!
!   ntars - the number of targets
!   itars - the list of targets
!   nsrcs - the number of sources
!   isrcs - the list of sources
!
!  Output parameters:
!    a - the (lda,ntars) matrix

data pi / 3.14159265358979323846264338327950288d0 /
integer, allocatable          :: itars00(:), itars0(:), itarsidxs(:)
integer, allocatable          :: isrcs00(:), isrcs0(:), isrcsidxs(:)
double precision, allocatable :: cmatr(:,:)


allocate(cmatr(nquad0,nquad0))

allocate(itars00(ntars))
allocate(isrcs00(nsrcs))


i1 = 0
i2 = 0

!
!  Loop over all target boxes
!

do while(i2 .lt. ntars) 

i1      = i2+1
itarbox = (itars(i1)-1)/nquad0+1
i3      = 1+(itarbox-1)*nquad0
i4      = (itarbox)*nquad0


do while(i2 .lt. ntars) 
if( itars(i2+1) .le. i4) then
i2=i2+1
else
exit
endif
end do

!
!  Loop over all source boxes
!

j1     = 0
j2     = 0

do while(j2 .lt. nsrcs) 

j1      = j2+1
isrcbox = (isrcs(j1)-1)/nquad0+1
j3      = 1+(isrcbox-1)*nquad0
j4      = (isrcbox)*nquad0

do while(j2 .lt. nsrcs) 
if( isrcs(j2+1) .le. j4) then
j2=j2+1
else
exit
endif
end do

!
!  Call a utility routine to evaluate the appropriate submatrix for this target
!  and this source
!

nn            = i2-i1+1
mm            = j2-j1+1
itars00(1:nn) = itars(i1:i2)-i3+1
isrcs00(1:mm) = isrcs(j1:j2)-j3+1
call discrect_evalopt0(tree,ikernel,itarbox,isrcbox,nn,itars00,mm,isrcs00,a(j1:j2,i1:i2))
end do
end do

end subroutine


subroutine discrect_evalop_block(tree,ikernel,itar,isrc,amatr)
implicit double precision (a-h,o-z)
type(resquadtree)      :: tree
double precision       :: amatr(:,:)
!
!  Evaluate a (nquad0,nquad0) submatrix of one of the operators (1), (2) or (3) 
!  corresponding to the interaction of one leaf node with another leaf node.
!  That is, the matrix which takes the scaled values of the input function
!  f at the discretization quadrature nodes on the source leaf box to
!  the scaled values of its image T[f] under one of the operators (1), (2)
!  or (3) at the discretization quadrature nodes on the target leaf box.
!
!  Input parameters:
!    tree - the data structure describing the restricted quadtree
!    ikernel - an integer parameter indicating which operator is to be
!      evaluated:
!
!        ikernel = 1   means evaluate a submatrix of the discretization of (1)
!        ikernel = 2   means evaluate a submatrix of the discretization of (2)
!        ikernel = 3   means evaluate a submatrix of the discretization of (3)
!
!   itar - the index of the target leaf
!   isrc - the index of the source leaf
!
!  Output parameters:
!    amatr - the (nquad0, nquad0) matrix

data pi / 3.14159265358979323846264338327950288d0 /
double precision, allocatable :: bmatr(:,:)
double precision, allocatable :: xs00(:),ys00(:),whts00(:)

!
!  Fetch the coordinates of the source and target boxes
!

isrcbox = tree%ileaves(isrc)
itarbox = tree%ileaves(itar)


call resquad_leafinfo(tree,isrc,isrcbox,ilevel,x1,y1,x2,y2)
call resquad_leafinfo(tree,itar,itarbox,ilevel,z1,w1,z2,w2)

!
!  Determine the distance of the target box from the source box (note that
!  this distance is not symmetric)
!

call resquad_distance(x1,y1,x2,y2,z1,w1,z2,w2,dist)

!
!  Handle a far interaction
!
if (dist .ge. dnear) then
allocate(xs00(nquad0),ys00(nquad0),whts00(nquad0))
xs00   = xs0*(x2-x1)/2 + (x2+x1)/2
ys00   = ys0*(y2-y1)/2 + (y2+y1)/2
whts00 = whts0*(x2-x1)/2*(y2-y1)/2

do i=1,nquad0
x0   = xs0(i)*(z2-z1)/2 + (z2+z1)/2
y0   = ys0(i)*(w2-w1)/2 + (w2+w1)/2
wht0 = whts0(i)*(z2-z1)/2*(w2-w1)/2

if (ikernel .eq. 1) then
amatr(i,1:nquad0) = 1/(4*pi)*log( (x0-xs00)**2 + (y0-ys00)**2 ) * sqrt(wht0)*sqrt(whts00)
elseif(ikernel .eq. 2) then
amatr(i,1:nquad0) = 1/(2*pi)*(x0-xs00)/( (x0-xs00)**2 + (ys00-y0)**2 ) * sqrt(wht0)*sqrt(whts00)
else
amatr(i,1:nquad0) = 1/(2*pi)*(y0-ys00)/( (x0-xs00)**2 + (ys00-y0)**2 ) * sqrt(wht0)*sqrt(whts00)
endif

end do
return
endif

!
!  Interactions for self and neighboring boxes are precomputed
!

if (dist .eq. 0.0d0 ) then

!
!  Apply the mapping which takes the source box to (-1,1) x (-1,1) to the
!  target box 
!

z3   = 2.0d0/(x2-x1)*z1 +  (x1+x2)/(x1-x2)
z4   = 2.0d0/(x2-x1)*z2 +  (x1+x2)/(x1-x2)
w3   = 2.0d0/(y2-y1)*w1 +  (y1+y2)/(y1-y2)
w4   = 2.0d0/(y2-y1)*w2 +  (y1+y2)/(y1-y2)
dlen = z4-z3


do iconfig=1,nconfigs
xx = configs(1,iconfig) 
yy = configs(2,iconfig) 
dd = configs(3,iconfig)-xx

if (xx .eq. z3 .AND. yy .eq. w3 .AND. dd .eq. dlen) exit
end do

if (iconfig .gt. nconfigs) then
print *,isrc,itar,z1,w1,z2,w2
call prina("discrect: configuation not found")
stop
endif

!
!  Copy over the precomputed near interaction matrix and scale it
!  appropriately
!
dlambda = (x2-x1)/2.0d0
deta    = (z2-z1)/2.0d0

if (ikernel .eq. 1) then
amatr = amatrlog(:,:,iconfig)
amatr      = amatr*dlambda**2
do i=1,nquad0
amatr(i,:) =  amatr(i,:)+dlambda*deta*log(dlambda)/(2*pi)*sqrt(whts0)*sqrt(whts0(i))
end do
elseif (ikernel .eq. 2) then
amatr      = amatrlogdx(:,:,iconfig)
amatr      = amatr*dlambda
else 
amatr      = amatrlogdy(:,:,iconfig)
amatr      = amatr*dlambda
endif
return
endif


!
!  Handle near but not neighboring interactions
!

allocate(bmatr(nquad0,nquadnear))

allocate(xs00(nquadnear),ys00(nquadnear),whts00(nquadnear))
xs00       = xsnear*(x2-x1)/2 + (x2+x1)/2
ys00       = ysnear*(y2-y1)/2 + (y2+y1)/2
whts00     = whtsnear*(x2-x1)/2*(y2-y1)/2

do i=1,nquad0
x0   = xs0(i)*(z2-z1)/2 + (z2+z1)/2
y0   = ys0(i)*(w2-w1)/2 + (w2+w1)/2
wht0 = whts0(i)*(z2-z1)/2*(w2-w1)/2

if (ikernel .eq. 1) then
bmatr(i,:) = 1/(4*pi)*log( (x0-xs00)**2 + (ys00-y0)**2 ) * sqrt(wht0)*sqrt(whts00)
elseif( ikernel .eq. 2) then
bmatr(i,:) = 1/(2*pi)*(x0-xs00)/( (x0-xs00)**2 + (ys00-y0)**2 ) * sqrt(wht0)*sqrt(whts00)
else
bmatr(i,:) = 1/(2*pi)*(y0-ys00)/( (x0-xs00)**2 + (ys00-y0)**2 ) * sqrt(wht0)*sqrt(whts00)
endif
end do

amatr = matmul(bmatr,amatrnear)

end subroutine


subroutine discrect_evalop_outgoing(tree,ikernel,ntars,xstar,ystar,whtstar,nsrcs,isrcs,amatr)
implicit double precision (a-h,o-z)
type(resquadtree)      :: tree
double precision       :: xstar(ntars),ystar(ntars),whtstar(ntars)
integer                :: isrcs(nsrcs)
double precision       :: amatr(:,:)
! 
!  Construct the matrix taking the scaled values of a function at a specified collection of
!  discretization nodes to the scaled values of its image under one of the operators
!  T1, T2 or T3 at the nodes of a user-specified quadrature rule which is distance
!  from the source points.
!
!  Input parameters:
!    tree - the data structure describing the restricted quadtree
!    ikernel - an integer parameter indicating which operator is to be
!      evaluated:
!
!        ikernel = 1   means evaluate a submatrix of the discretization of (1)
!        ikernel = 2   means evaluate a submatrix of the discretization of (2)
!        ikernel = 3   means evaluate a submatrix of the discretization of (3)
!
!   (ntars,xstar,ystar,whtstar) - the target quadrature rule
!
!   nsrcs - the number of source points
!   isrcs - the indices of the source points
!
!  Output parameters:
!   amatr - the desired matrix
!
!
data pi / 3.14159265358979323846264338327950288d0 /


do j=1,nsrcs
jj      = isrcs(j)
isrcbox = (jj-1)/nquad0+1
j1      = 1+(isrcbox-1)*nquad0
j2      = (isrcbox)*nquad0

call resquad_leafinfo(tree,isrcbox,ibox,ilevel,x1,y1,x2,y2)

jjj  = jj-j1+1
x    = xs0(jjj)*(x2-x1)/2 + (x2+x1)/2
y    = ys0(jjj)*(y2-y1)/2 + (y2+y1)/2
wht  = whts0(jjj)*(x2-x1)/2*(y2-y1)/2

if (ikernel .eq. 1) then
amatr(:,j) = 1/(4*pi)*log( (xstar-x)**2 + (ystar-y)**2 ) * sqrt(wht)*sqrt(whtstar)
elseif(ikernel .eq. 2) then
amatr(:,j) = 1/(2*pi)*(xstar-x)/( (xstar-x)**2 + (y-ystar)**2 ) * sqrt(whtstar)*sqrt(wht)
else
amatr(:,j) = 1/(2*pi)*(ystar-y)/( (xstar-x)**2 + (y-ystar)**2 ) * sqrt(whtstar)*sqrt(wht)
endif
end do

end subroutine


subroutine discrect_evalop_outgoing_all(tree,ikernel,ntars,xstar,ystar,whtstar,amatr)
implicit double precision (a-h,o-z)
type(resquadtree)      :: tree
double precision       :: xstar(ntars),ystar(ntars),whtstar(ntars)
double precision       :: amatr(:,:)
! 
!  Construct the matrix taking the scaled values of a function at all of the
!  discretization nodes to the scaled values of its image under one of the operators
!  T1, T2 or T3 at the nodes of a user-specified quadrature rule which is distance
!  from the source points.
!
!  Input parameters:
!    tree - the data structure describing the restricted quadtree
!    ikernel - an integer parameter indicating which operator is to be
!      evaluated:
!
!        ikernel = 1   means evaluate a submatrix of the discretization of (1)
!        ikernel = 2   means evaluate a submatrix of the discretization of (2)
!        ikernel = 3   means evaluate a submatrix of the discretization of (3)
!
!   (ntars,xstar,ystar,whtstar) - the target quadrature rule
!
!  Output parameters:
!   amatr - the desired matrix
!
!
data pi / 3.14159265358979323846264338327950288d0 /


nleaves = tree%nleaves

do isrcbox=1,nleaves
call resquad_leafinfo(tree,isrcbox,ibox,ilevel,x1,y1,x2,y2)
jdelta  = (isrcbox-1)*nquad0
do j=1,nquad0

x    = xs0(j)*(x2-x1)/2 + (x2+x1)/2
y    = ys0(j)*(y2-y1)/2 + (y2+y1)/2
wht  = whts0(j)*(x2-x1)/2*(y2-y1)/2


if (ikernel .eq. 1) then
amatr(1:ntars,j+jdelta) = 1/(4*pi)*log( (xstar-x)**2 + (ystar-y)**2 ) * sqrt(wht)*sqrt(whtstar)
elseif(ikernel .eq. 2) then
amatr(1:ntars,j+jdelta) = 1/(2*pi)*(xstar-x)/( (xstar-x)**2 + (y-ystar)**2 ) * sqrt(whtstar)*sqrt(wht)
else
amatr(1:ntars,j+jdelta) = 1/(2*pi)*(ystar-y)/( (xstar-x)**2 + (y-ystar)**2 ) * sqrt(whtstar)*sqrt(wht)
endif

end do

end do

end subroutine



subroutine discrect_evalop_incoming(tree,ikernel,ntars,itars,nsrcs,xssrc,yssrc,whtssrc,amatr)
implicit double precision (a-h,o-z)
type(resquadtree)      :: tree
double precision       :: xssrc(nsrcs),yssrc(nsrcs),whtssrc(nsrcs)
integer                :: itars(ntars)
double precision       :: amatr(:,:)
!
!  Construct the TRANSPOSE of the matrix taking the scaled values of a function at a specified 
!  quadrature rule to the scaled values of its image under one of the operators T1, T2 or T3 at 
!  a specified collection of discretization nodes which are distance from the source points.
!
!  Input parameters:
!
!    tree - the data structure describing the restricted quadtree
!    ikernel - an integer parameter indicating which operator is to be
!      evaluated:
!
!        ikernel = 1   means evaluate a submatrix of the discretization of (1)
!        ikernel = 2   means evaluate a submatrix of the discretization of (2)
!        ikernel = 3   means evaluate a submatrix of the discretization of (3)
!
!   (nsrcs,xssrcs,yssrcs,whtssrcs) - the sourc quadrature rule
!
!   ntars - the number of target points
!   itars - the indices of the target points
!
!  Output parameters:
!   amatr - the desired matrix
!
!
!
data pi / 3.14159265358979323846264338327950288d0 /


do i=1,ntars
ii      = itars(i)
itarbox = (ii-1)/nquad0+1
i1      = 1+(itarbox-1)*nquad0
i2      = (itarbox)*nquad0

call resquad_leafinfo(tree,itarbox,ibox,ilevel,x1,y1,x2,y2)

iii  = ii-i1+1
x    = xs0(iii)*(x2-x1)/2 + (x2+x1)/2
y    = ys0(iii)*(y2-y1)/2 + (y2+y1)/2
wht  = whts0(iii)*(x2-x1)/2*(y2-y1)/2

if (ikernel .eq. 1) then
amatr(1:nsrcs,i) = 1/(4*pi)*log( (x-xssrc)**2 + (yssrc-y)**2 ) * sqrt(wht)*sqrt(whtssrc)
elseif(ikernel .eq. 2) then
amatr(1:nsrcs,i) = 1/(2*pi)*(x-xssrc)/( (x-xssrc)**2 + (yssrc-y)**2 ) * sqrt(wht)*sqrt(whtssrc)
else
amatr(1:nsrcs,i) = 1/(2*pi)*(y-yssrc)/( (x-xssrc)**2 + (yssrc-y)**2 ) * sqrt(wht)*sqrt(whtssrc)
endif

end do

end subroutine


subroutine discrect_evalop0(tree,ikernel,itar,isrc,ntars,itars,nsrcs,isrcs,amatr)
implicit double precision (a-h,o-z)
type(resquadtree)      :: tree
double precision       :: amatr(:,:)
integer                :: itars(ntars), isrcs(nsrcs)

data pi       / 3.14159265358979323846264338327950288d0 /
data over4pi  / 0.0795774715459476678844418816862571810 /

double precision, allocatable :: bmatr(:,:),amatrnear0(:,:)
double precision, allocatable :: xs00(:),ys00(:),whts00(:)
!
!  Fetch the coordinates of the source and target boxes
!

call resquad_leafinfo(tree,isrc,isrcbox,ilevel,x1,y1,x2,y2)
call resquad_leafinfo(tree,itar,itarbox,ilevel,z1,w1,z2,w2)

!
!  Determine the distance of the target box from the source box (note that
!  this distance is not symmetric)
!

call resquad_distance(x1,y1,x2,y2,z1,w1,z2,w2,dist)

!
!  This is a "far" interaction
!

if (dist .ge. dnear) then
allocate(xs00(nsrcs),ys00(nsrcs),whts00(nsrcs))
xs00   = xs0(isrcs)*(x2-x1)/2 + (x2+x1)/2
ys00   = ys0(isrcs)*(y2-y1)/2 + (y2+y1)/2
whts00 = whts0(isrcs)*(x2-x1)/2*(y2-y1)/2

do i=1,ntars
x0   = xs0(itars(i))*(z2-z1)/2 + (z2+z1)/2
y0   = ys0(itars(i))*(w2-w1)/2 + (w2+w1)/2
wht0 = whts0(itars(i))*(z2-z1)/2*(w2-w1)/2
if (ikernel .eq. 1) then
amatr(i,1:nsrcs) = 1/(4*pi)*log( (x0-xs00)**2 + (y0-ys00)**2 ) * sqrt(wht0)*sqrt(whts00)
elseif(ikernel .eq. 2) then
amatr(i,:) = 1/(2*pi)*(x0-xs00)/( (x0-xs00)**2 + (ys00-y0)**2 ) * sqrt(wht0)*sqrt(whts00)
else
amatr(i,:) = 1/(2*pi)*(y0-ys00)/( (x0-xs00)**2 + (ys00-y0)**2 ) * sqrt(wht0)*sqrt(whts00)
endif
end do
return
endif


!
!  Interactions for self and neighboring boxes are precomputed
!

if (dist .eq. 0.0d0 ) then

!
!  Apply the mapping which takes the source box to (-1,1) x (-1,1) to the
!  target box 
!

z3   = 2.0d0/(x2-x1)*z1 +  (x1+x2)/(x1-x2)
z4   = 2.0d0/(x2-x1)*z2 +  (x1+x2)/(x1-x2)
w3   = 2.0d0/(y2-y1)*w1 +  (y1+y2)/(y1-y2)
w4   = 2.0d0/(y2-y1)*w2 +  (y1+y2)/(y1-y2)
dlen = z4-z3

do iconfig=1,nconfigs
xx = configs(1,iconfig) 
yy = configs(2,iconfig) 
dd = configs(3,iconfig)-xx

if (xx .eq. z3 .AND. yy .eq. w3 .AND. dd .eq. dlen) exit
end do

if (iconfig .gt. nconfigs) then
print *,isrc,itar,z1,w1,z2,w2
call prina("discrect: configuation not found")
stop
endif

!
!  Copy over the precomputed near interaction matrix and scale it
!  appropriately ... 
!

dlambda = (x2-x1)/2.0d0
deta    = (z2-z1)/2.0d0

if (ikernel .eq. 1) then
amatr(1:ntars,1:nsrcs)      = amatrlog(itars,isrcs,iconfig)
amatr(1:ntars,1:nsrcs)      = amatr(1:ntars,1:nsrcs)*dlambda**2
do i=1,ntars
amatr(i,1:nsrcs) =  amatr(i,1:nsrcs)+dlambda*deta*log(dlambda)/(2*pi)*sqrt(whts0(isrcs))*sqrt(whts0(itars(i)))
end do
elseif (ikernel .eq. 2) then
amatr(1:ntars,1:nsrcs)      = amatrlogdx(itars,isrcs,iconfig)
amatr(1:nsrcs,1:nsrcs)      = amatr(1:ntars,1:nsrcs)*dlambda
else 
amatr(1:ntars,1:nsrcs)      = amatrlogdy(itars,isrcs,iconfig)
amatr(1:nsrcs,1:nsrcs)      = amatr(1:ntars,1:nsrcs)*dlambda
endif

return
endif

!
!  Handle near but not neighboring interactions
!

allocate(bmatr(ntars,nquadnear),amatrnear0(nquadnear,nsrcs))

allocate(xs00(nquadnear),ys00(nquadnear),whts00(nquadnear))
xs00       = xsnear*(x2-x1)/2 + (x2+x1)/2
ys00       = ysnear*(y2-y1)/2 + (y2+y1)/2
whts00     = whtsnear*(x2-x1)/2*(y2-y1)/2
amatrnear0 = amatrnear(:,isrcs)

do i=1,ntars
x0   = xs0(itars(i))*(z2-z1)/2 + (z2+z1)/2
y0   = ys0(itars(i))*(w2-w1)/2 + (w2+w1)/2
wht0 = whts0(itars(i))*(z2-z1)/2*(w2-w1)/2

if (ikernel .eq. 1) then
bmatr(i,:) = 1/(4*pi)*log( (x0-xs00)**2 + (ys00-y0)**2 ) * sqrt(wht0)*sqrt(whts00)
elseif( ikernel .eq. 2) then
bmatr(i,:) = 1/(2*pi)*(x0-xs00)/( (x0-xs00)**2 + (ys00-y0)**2 ) * sqrt(wht0)*sqrt(whts00)
else
bmatr(i,:) = 1/(2*pi)*(y0-ys00)/( (x0-xs00)**2 + (ys00-y0)**2 ) * sqrt(wht0)*sqrt(whts00)
endif
end do

amatr = matmul(bmatr,amatrnear0)

end subroutine


subroutine discrect_evalopt0(tree,ikernel,itar,isrc,ntars,itars,nsrcs,isrcs,amatr)
implicit double precision (a-h,o-z)
type(resquadtree)      :: tree
double precision       :: amatr(:,:)
integer                :: itars(ntars), isrcs(nsrcs)

data pi       / 3.14159265358979323846264338327950288d0 /
data over4pi  / 0.0795774715459476678844418816862571810 /

double precision, allocatable :: bmatr(:,:),amatrnear0(:,:),b1(:,:),b2(:,:)
double precision, allocatable :: xs00(:),ys00(:),whts00(:)
!
!  Fetch the coordinates of the source and target boxes
!

call resquad_leafinfo(tree,isrc,isrcbox,ilevel,x1,y1,x2,y2)
call resquad_leafinfo(tree,itar,itarbox,ilevel,z1,w1,z2,w2)

!
!  Determine the distance of the target box from the source box (note that
!  this distance is not symmetric)
!

call resquad_distance(x1,y1,x2,y2,z1,w1,z2,w2,dist)

!
!  This is a "far" interaction
!

if (dist .ge. dnear) then
allocate(xs00(nsrcs),ys00(nsrcs),whts00(nsrcs))
xs00   = xs0(isrcs)*(x2-x1)/2 + (x2+x1)/2
ys00   = ys0(isrcs)*(y2-y1)/2 + (y2+y1)/2
whts00 = whts0(isrcs)*(x2-x1)/2*(y2-y1)/2

do i=1,ntars
x0   = xs0(itars(i))*(z2-z1)/2 + (z2+z1)/2
y0   = ys0(itars(i))*(w2-w1)/2 + (w2+w1)/2
wht0 = whts0(itars(i))*(z2-z1)/2*(w2-w1)/2
if (ikernel .eq. 1) then
amatr(1:nsrcs,i) = 1/(4*pi)*log( (x0-xs00)**2 + (y0-ys00)**2 ) * sqrt(wht0)*sqrt(whts00)
elseif(ikernel .eq. 2) then
amatr(:,i) = 1/(2*pi)*(x0-xs00)/( (x0-xs00)**2 + (ys00-y0)**2 ) * sqrt(wht0)*sqrt(whts00)
else
amatr(:,i) = 1/(2*pi)*(y0-ys00)/( (x0-xs00)**2 + (ys00-y0)**2 ) * sqrt(wht0)*sqrt(whts00)
endif
end do
return
endif


!
!  Interactions for self and neighboring boxes are precomputed
!

if (dist .eq. 0.0d0 ) then

!
!  Apply the mapping which takes the source box to (-1,1) x (-1,1) to the
!  target box 
!

z3   = 2.0d0/(x2-x1)*z1 +  (x1+x2)/(x1-x2)
z4   = 2.0d0/(x2-x1)*z2 +  (x1+x2)/(x1-x2)
w3   = 2.0d0/(y2-y1)*w1 +  (y1+y2)/(y1-y2)
w4   = 2.0d0/(y2-y1)*w2 +  (y1+y2)/(y1-y2)
dlen = z4-z3

do iconfig=1,nconfigs
xx = configs(1,iconfig) 
yy = configs(2,iconfig) 
dd = configs(3,iconfig)-xx

if (xx .eq. z3 .AND. yy .eq. w3 .AND. dd .eq. dlen) exit
end do

if (iconfig .gt. nconfigs) then
print *,isrc,itar,z1,w1,z2,w2
call prina("discrect: configuation not found")
stop
endif

!
!  Copy over the precomputed near interaction matrix and scale it
!  appropriately ... 
!



dlambda = (x2-x1)/2.0d0
deta    = (z2-z1)/2.0d0

allocate(b1(ntars,nsrcs))

if (ikernel .eq. 1) then
b1                          = amatrlog(itars,isrcs,iconfig) 
b1                          = b1*dlambda**2
do i=1,ntars
b1(i,1:nsrcs) =  b1(i,1:nsrcs)+dlambda*deta*log(dlambda)/(2*pi)*sqrt(whts0(isrcs))*sqrt(whts0(itars(i)))
end do
elseif (ikernel .eq. 2) then
b1(1:ntars,1:nsrcs)      = amatrlogdx(itars,isrcs,iconfig)
b1(1:nsrcs,1:nsrcs)      = b1(1:ntars,1:nsrcs)*dlambda
else 
b1(1:ntars,1:nsrcs)      = amatrlogdy(itars,isrcs,iconfig)
b1(1:nsrcs,1:nsrcs)      = b1(1:ntars,1:nsrcs)*dlambda
endif

amatr(1:nsrcs,1:ntars)      = transpose(b1)

return
endif

!
!  Handle near but not neighboring interactions
!

allocate(bmatr(nquadnear,ntars),amatrnear0(nsrcs,nquadnear))

allocate(xs00(nquadnear),ys00(nquadnear),whts00(nquadnear))
xs00       = xsnear*(x2-x1)/2 + (x2+x1)/2
ys00       = ysnear*(y2-y1)/2 + (y2+y1)/2
whts00     = whtsnear*(x2-x1)/2*(y2-y1)/2
amatrnear0 = amatrnear(isrcs,:)

do i=1,ntars
x0   = xs0(itars(i))*(z2-z1)/2 + (z2+z1)/2
y0   = ys0(itars(i))*(w2-w1)/2 + (w2+w1)/2
wht0 = whts0(itars(i))*(z2-z1)/2*(w2-w1)/2

if (ikernel .eq. 1) then
bmatr(:,i) = 1/(4*pi)*log( (x0-xs00)**2 + (ys00-y0)**2 ) * sqrt(wht0)*sqrt(whts00)
elseif( ikernel .eq. 2) then
bmatr(:,i) = 1/(2*pi)*(x0-xs00)/( (x0-xs00)**2 + (ys00-y0)**2 ) * sqrt(wht0)*sqrt(whts00)
else
bmatr(:,i) = 1/(2*pi)*(y0-ys00)/( (x0-xs00)**2 + (ys00-y0)**2 ) * sqrt(wht0)*sqrt(whts00)
endif
end do

amatr = matmul(amatrnear0,bmatr)

end subroutine


end module
